{
  "name": "ABike Connection",
  "connectionType": "kafka",
  "connectionStatus": "open",
  "uri": "tcp://kafka-broker:9092",
  "sources": [
    {
      "addresses": [
        "abike-update"
      ],
      "consumerCount": 1,
      "qos": 1,
      "authorizationContext": [
        "nginx:ditto"
      ],
      "acknowledgementRequests": {
        "includes": []
      },
      "headerMapping": {},
      "payloadMapping": [
        "JavaScript"
      ],
      "replyTarget": {
        "address": "EBIKE-REPLIES",
        "headerMapping": {},
        "expectedResponseTypes": [
          "response",
          "error",
          "nack"
        ],
        "enabled": true
      }
    }
  ],
  "targets": [],
  "clientCount": 1,
  "failoverEnabled": true,
  "validateCertificates": true,
  "processorPoolSize": 1,
  "specificConfig": {
    "bootstrapServers": "kafka-broker:9092"
  },
  "tags": [],
  "mappingDefinitions": {
    "JavaScript": {
      "mappingEngine": "JavaScript",
      "options": {
        "incomingScript": "function mapToDittoProtocolMsg(headers, textPayload, bytePayload, contentType) { if (contentType !== 'application/json') return null; var jsonData; try { jsonData = JSON.parse(textPayload); } catch (e) { return null; } var thingId = jsonData.thingId || jsonData.id || headers['device_id'] || headers['ce-id']; if (!thingId) return null; delete jsonData.thingId; delete jsonData.id; var features = {}; for (var key in jsonData) if (jsonData.hasOwnProperty(key)) features[key] = { properties: { value: jsonData[key] } }; var topic = headers['kafka.topic'] || ''; return Ditto.buildDittoProtocolMsg('default', thingId, 'things', 'twin', 'commands', 'modify', '/features', headers, features, { topic: topic }); }",
        "outgoingScript": "function mapFromDittoProtocolMsg(namespace, id, group, channel, criterion, action, path, dittoHeaders, value) { return { headers: dittoHeaders, payload: JSON.stringify(value), contentType: \"application/json\" }; }"
      }
    }
  }
}